using System;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.Extensions.Logging;
using Serious.Abbot.Entities;
using Serious.Logging;

namespace Serious.Abbot.Infrastructure;

public class Migrator
{
    static readonly ILogger<Migrator> Log = ApplicationLoggerFactory.CreateLogger<Migrator>();

    readonly AbbotContext _db;

    // The migration that was at the end of the history when migrations were last squashed
    // If this migration is applied to the database, then we consider the first migration in the app to have also been applied.
    // The first migration (Base) is a special migration that is generated by squashing existing migrations into one.
    // The squashing process is just to simplify new database creation. Existing databases have the full history of migrations.
    public static readonly string PreviousBaseMigration = "20220825173044_AddDefaultResponderProperty";
    public static readonly string NewBaseMigration = "20220901163528_Base";

    public Migrator(AbbotContext db)
    {
        _db = db;
    }

    public async Task ApplyMigrationsAsync()
    {
        // First, get the list of applied migrations
        var applied = (await _db.Database.GetAppliedMigrationsAsync()).ToList();

        // If the previous base migration is applied, but the new base is not, then we mark the new base as "applied"
        // The new base migration is always created from "squashing" everything up to the previous base into a single migration.
        if (!applied.Contains(NewBaseMigration, StringComparer.OrdinalIgnoreCase)
            && applied.Contains(PreviousBaseMigration, StringComparer.OrdinalIgnoreCase))
        {
            var historyRepo = _db.Database.GetService<IHistoryRepository>();
            var script = historyRepo.GetInsertScript(new HistoryRow(NewBaseMigration, ProductInfo.GetVersion()));
            await _db.Database.ExecuteSqlRawAsync(script);
        }

        var pending = (await _db.Database.GetPendingMigrationsAsync()).ToList();
        if (!pending.Any())
        {
            return;
        }

        var allMigrations = string.Join(", ", pending);
        Log.RunningMigrations(allMigrations);

        // Now run migrations.
        await _db.Database.MigrateAsync();

        Log.MigrationsComplete();
    }
}

public static partial class MigratorLoggingExtensions
{
    [LoggerMessage(EventId = 1, Level = LogLevel.Information, Message = "Applying migrations: {Migrations}")]
    public static partial void RunningMigrations(this ILogger<Migrator> logger, string migrations);

    [LoggerMessage(
        EventId = 2,
        Level = LogLevel.Information,
        Message = "Migrations complete, seeding dataâ€¦")]
    public static partial void MigrationsComplete(this ILogger<Migrator> logger);
}
