using System;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.DataProtection;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Newtonsoft.Json;
using Serious.Abbot.Entities;
using Serious.Abbot.Security;
using Serious.AspNetCore;
using Serious.Cryptography;

namespace Serious.Abbot.Controllers.InternalApi;

[Authorize(Roles = Roles.Staff)]
[Route("api/internal/staff/export")]
public class ExportsController : InternalApiControllerBase
{
    readonly AbbotContext _db;
    readonly IDataProtector _protector;

    public ExportsController(AbbotContext db, IDataProtectionProvider dataProtectionProvider)
    {
        _db = db;
        _protector = dataProtectionProvider.CreateProtector(nameof(ExportsController));
    }

    /// <summary>
    /// This generates a temporary key the client can use to download the file. The reason we do this is we can't
    /// easily cause the browser to download the file in response to an HTTP POST request. We also want to avoid
    /// CSRF attacks.
    /// </summary>
    /// <param name="id">The id of the room.</param>
    [HttpPost("room")]
    public IActionResult InitiateExportRoomAsync(int id)
    {
        var expiration = DateTimeOffset.UtcNow.AddMinutes(5);
        var expirationTicks = expiration.Ticks.ToString(CultureInfo.InvariantCulture);
        var key = new SecretString($"{id}|{expirationTicks}", _protector).ProtectedValue;

        return Request.IsAjaxRequest()
            ? Json(new { key })
            : RedirectToRoute(new { id, key });
    }

    /// <summary>
    /// This generates the actual export download. It requires calling the same endpoint with HTTP POST first.
    /// </summary>
    /// <param name="id">The Id of the room.</param>
    /// <param name="key">The key generated by an HTTP POST request.</param>
    [HttpGet("room")]
    public async Task<IActionResult> ExportRoomAsync(int id, string key)
    {
        var secret = new SecretString(key, _protector).Reveal();
        if (!ValidateExportKey(secret, id))
        {
            return BadRequest();
        }

        var room = await _db.Rooms
            .AsNoTrackingWithIdentityResolution()
            .Include(r => r.Conversations)
            .ThenInclude(r => r.Events)
            .ThenInclude(e => e.Member)
            .Include(r => r.Conversations)
            .ThenInclude(c => c.StartedBy)
            .SingleOrDefaultAsync(r => r.Id == id);
        if (room is null)
        {
            return NotFound();
        }

        var data = JsonConvert.SerializeObject(
            GetRoom(room),
            Formatting.Indented);

        byte[] fileContent = Encoding.UTF8.GetBytes(data);
        return File(fileContent, "application/octet-stream", "room.json");
    }

    static bool ValidateExportKey(string value, int id)
    {
        var parts = value.Split('|');
        return parts.Length == 2
               && int.TryParse(parts[0], out var exportedRoomId)
               && exportedRoomId == id
               && long.TryParse(parts[1], out var expirationTicks)
               && new DateTime(expirationTicks, DateTimeKind.Utc) > DateTimeOffset.UtcNow;
    }

    static object GetRoom(Room room)
    {
        var platformRoomId = $"C0{TokenCreator.CreateRandomString(6)}";
        return new {
            room.OrganizationId,
            PlatformRoomId = platformRoomId,
            ConversationId = platformRoomId,
            room.Persistent,
            room.ManagedConversationsEnabled,
            Conversations = room.Conversations.Select(GetConversation),
            room.RoomType,
            room.Deleted,
            room.Archived,
            room.BotIsMember,
            room.Modified,
            room.TimeToRespond,
            room.Settings,
            room.LastPlatformUpdate
        };
    }

    static object GetConversation(Conversation conversation)
    {
        return new {
            conversation.Created,
            conversation.FirstMessageId,
            conversation.FirstResponseOn,
            conversation.ClosedOn,
            conversation.TimeToRespondWarningNotificationSent,
            conversation.ArchivedOn,
            conversation.LastStateChangeOn,
            conversation.LastMessagePostedOn,
            conversation.State,
            StartedBy = GetMember(conversation.StartedBy),
            Events = conversation.Events.Select(GetEvent)
        };
    }

    static object GetMember(Member member)
    {
        return new { member.Id, member.OrganizationId, member.TimeZoneId };
    }

    static object GetEvent(ConversationEvent conversationEvent)
    {
        var id = conversationEvent.Id;
        var conversationId = conversationEvent.ConversationId;
        var created = conversationEvent.Created;
        var member = GetMember(conversationEvent.Member);
        return conversationEvent switch
        {
            StateChangedEvent stateChangedEvent => new {
                Type = "StateChanged",
                Created = created,
                Member = member,
                ConversationId = conversationId,
                stateChangedEvent.Implicit,
                stateChangedEvent.OldState,
                stateChangedEvent.NewState
            },
            MessagePostedEvent messagePostedEvent => new {
                Type = "MessagePosted",
                Created = created,
                Member = member,
                ConversationId = conversationId,
                messagePostedEvent.MessageId,
                messagePostedEvent.MessageUrl
            },
            _ => new { }
        };
    }
}
