using System;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using Serious.Abbot.Entities;
using Serious.Abbot.Repositories;
using Serious.Abbot.Scripting;

namespace Serious.Abbot.Validation;

/// <summary>
/// Used to validate a pattern.
/// </summary>
public class PatternValidator : IPatternValidator
{
    readonly IPatternRepository _patternRepository;

    public PatternValidator(IPatternRepository patternRepository)
    {
        _patternRepository = patternRepository;
    }

    /// <summary>
    /// Determines whether the pattern name is unique across all the pattern for the skill.
    /// </summary>
    /// <param name="name">Name of the pattern to test.</param>
    /// <param name="id">Id of the current pattern.</param>
    /// <param name="skill">Name of the skill the pattern belongs to.</param>
    /// <param name="organization">The organization the skill belongs to.</param>
    /// <returns>True if the name is unique for the skill.</returns>
    public async Task<bool> IsUniqueNameAsync(string name, int? id, string skill, Organization organization)
    {
        // Instead of using the name to look up the pattern, we should use the slug that would 
        // be generated by the name because THAT has to be unique and it's normalized so we 
        // don't have to worry about case sensitivity issues.
        var slugCandidate = name.ToSlug();
        var pattern = id is not null ? await _patternRepository.GetAsync(skill, slugCandidate, organization) : null;

        // It's only unique if we didn't find a pattern with the specified name OR 
        return pattern is null || pattern.Id == id.GetValueOrDefault();
    }

    /// <summary>
    /// Determines whether the pattern is valid for the pattern type.
    /// </summary>
    /// <remarks>This only does something interesting for <see cref="PatternType.RegularExpression"/> patterns.</remarks>
    /// <param name="pattern">The pattern to test.</param>
    /// <param name="patternType">The pattern type.</param>
    /// <returns>True if the pattern is valid.</returns>
    public bool IsValidPattern(string pattern, PatternType patternType)
    {
        bool IsValidRegex()
        {
            try
            {
                _ = Regex.Match("", pattern);
                return true;
            }
            catch (ArgumentException)
            {
                return false;
            }
        }

        return patternType switch
        {
            PatternType.None or PatternType.Contains or PatternType.StartsWith or PatternType.EndsWith or PatternType.ExactMatch => true,
            PatternType.RegularExpression => IsValidRegex(),
            _ => throw new ArgumentException($"Invalid pattern type {patternType}.", nameof(patternType))
        };
    }
}
